import { date, ISchemaAny, number, string } from '@ulixee/schema';
import StringSchema from '@ulixee/schema/lib/StringSchema';
import DateSchema from '@ulixee/schema/lib/DateSchema';
import TypeSerializer from '@ulixee/commons/lib/TypeSerializer';
import { SqlGenerator } from '@ulixee/sql-engine';
import addGlobalInstance from '@ulixee/commons/lib/addGlobalInstance';
import moment = require('moment');
import Runner from './Runner';
import IRunnerSchema, { ISchemaRecordType } from '../interfaces/IRunnerSchema';
import { IRunnerPluginConstructor } from '../interfaces/IRunnerPluginStatics';
import IRunnerContext from '../interfaces/IRunnerContext';
import ICrawlerComponents from '../interfaces/ICrawlerComponents';
import ICrawlerOutputSchema, { CrawlerOutputSchema } from '../interfaces/ICrawlerOutputSchema';
import Table from './Table';
import DatastoreInternal from './DatastoreInternal';

export default class Crawler<
  TDisableCache extends boolean = false,
  TProvidedSchema extends IRunnerSchema<unknown, never> = IRunnerSchema<unknown, never>,
  TFinalInput extends ISchemaRecordType<any> = TDisableCache extends true
    ? TProvidedSchema['input']
    : TProvidedSchema extends { input: Record<string, ISchemaAny> }
    ? typeof CrawlerInputSchema & TProvidedSchema['input']
    : typeof CrawlerInputSchema & Record<string, ISchemaAny>,
  TSchema extends IRunnerSchema<TFinalInput, typeof CrawlerOutputSchema> = IRunnerSchema<
    TFinalInput,
    typeof CrawlerOutputSchema
  >,
  TPlugin1 extends IRunnerPluginConstructor<TSchema> = IRunnerPluginConstructor<TSchema>,
  TPlugin2 extends IRunnerPluginConstructor<TSchema> = IRunnerPluginConstructor<TSchema>,
  TPlugin3 extends IRunnerPluginConstructor<TSchema> = IRunnerPluginConstructor<TSchema>,
  TContext extends Omit<IRunnerContext<TSchema>, 'Output' | 'outputs'> &
    TPlugin1['contextAddons'] &
    TPlugin2['contextAddons'] &
    TPlugin3['contextAddons'] = Omit<IRunnerContext<TSchema>, 'Output' | 'outputs'> &
    TPlugin1['contextAddons'] &
    TPlugin2['contextAddons'] &
    TPlugin3['contextAddons'],
> extends Runner<TSchema, TPlugin1, TPlugin2, TPlugin3, TContext> {
  public static defaultMaxTimeInCache = 10 * 60e3;

  public override runnerType = 'crawler';
  public cache?: Table<{
    input: StringSchema<false>;
    sessionId: StringSchema<false>;
    crawler: StringSchema<false>;
    version: StringSchema<false>;
    runTime: DateSchema<false>;
  }>;

  private crawlerComponents: ICrawlerComponents<TSchema, TContext, TDisableCache> &
    TPlugin1['componentAddons'] &
    TPlugin2['componentAddons'] &
    TPlugin3['componentAddons'];

  constructor(
    components:
      | (ICrawlerComponents<TProvidedSchema, TContext, TDisableCache> &
          TPlugin1['componentAddons'] &
          TPlugin2['componentAddons'] &
          TPlugin3['componentAddons'])
      | (ICrawlerComponents<TProvidedSchema, TContext, TDisableCache> &
          TPlugin1['componentAddons'] &
          TPlugin2['componentAddons'] &
          TPlugin3['componentAddons'])['run'],
    ...plugins: [plugin1?: TPlugin1, plugin2?: TPlugin2, plugin3?: TPlugin3]
  ) {
    super({ ...components } as any, ...plugins);
    this.components.run = this.runWrapper.bind(this, this.components.run as any);
    this.crawlerComponents = this.components as any;
  }

  public override attachToDatastore(
    datastoreInternal: DatastoreInternal<any, any>,
    runnerName: string,
  ): void {
    super.attachToDatastore(datastoreInternal, runnerName);
    if (!this.crawlerComponents.disableCache) {
      this.cache = new Table({
        isPublic: false,
        name: `crawler_cache_${runnerName}`,
        schema: {
          input: string({ description: 'Typeserialized json of the inputs' }),
          sessionId: string({
            description: 'The scraper specific session id generated by toCrawlerOutput.',
          }),
          crawler: string(),
          version: string({ description: 'The crawler version.' }),
          runTime: date({ past: true, description: 'The time this session was run.' }),
        },
      });
      datastoreInternal.attachTable(this.cache);
    }
  }

  protected async runWrapper(
    originalRun: ICrawlerComponents<TSchema, TContext>['run'],
    context: TContext,
  ): Promise<void> {
    const { outputs, Output, datastoreMetadata, input, schema, ...rest } =
      context as IRunnerContext<TSchema>;
    const cached = await this.findCached(input as TContext['input']);
    if (cached) {
      Output.emit(cached as any);
      return;
    }

    const result = await originalRun({ input, schema, ...rest } as any);
    const output = await result.toCrawlerOutput();
    Output.emit(output as any);
    await this.saveToCache(input as TContext['input'], output);
  }

  protected async saveToCache(
    input: TContext['input'],
    output: ICrawlerOutputSchema,
  ): Promise<void> {
    if (this.crawlerComponents.disableCache) return null;
    const serializedInput = this.getSerializedInput(input);
    await this.cache.queryInternal('DELETE FROM self WHERE input=$1', [serializedInput]);
    const { sql, values } = SqlGenerator.createInsertStatement('self', this.cache.schema, {
      input: serializedInput,
      ...output,
      runTime: new Date(),
    });
    await this.cache.queryInternal(sql, values);
  }

  protected async findCached(input: TContext['input']): Promise<ICrawlerOutputSchema> {
    if (this.crawlerComponents.disableCache) return null;
    (input as ICrawlerInputSchema).maxTimeInCache ??= Crawler.defaultMaxTimeInCache;

    const maxAge = moment().add(-input.maxTimeInCache, 'seconds').toISOString();
    const serializedInput = this.getSerializedInput(input);

    const cached = await this.cache.queryInternal(
      `select * from self where runTime >= $1 and input=$2 limit 1`,
      [maxAge, serializedInput],
    );

    if (cached.length) {
      const [{ sessionId, version, crawler }] = cached;
      return { sessionId, version, crawler };
    }
    return null;
  }

  protected getSerializedInput(input: TContext['input']): string {
    const { maxTimeInCache, sessionId, ...inputArgs } = input;
    return TypeSerializer.stringify(inputArgs, { sortKeys: true });
  }
}

addGlobalInstance(Crawler);

const CrawlerInputSchema = {
  maxTimeInCache: number({
    min: 0,
    integer: true,
    optional: true,
    description: 'The maximum age in seconds of a cached web session.',
  }),
};

interface ICrawlerInputSchema {
  maxTimeInCache?: number;
}
